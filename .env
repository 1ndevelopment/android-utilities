arch() { ARCH=$(uname -m) ; [ "$ARCH" = aarch64 ] && { ARCH="arm64" && echo $ARCH ;} ; }

silence() { "$@" >/dev/null 2>&1; }
sha() { sha256sum "$TMP"/"$1" | awk '{print substr($1, length($1) - 6)}' ; }
list_installed() { dpkg --get-selections | awk '{print $1}' | sed 's|/.*||' | tr '\n' ' ' | sed 's/ $/\n/' ; }
cmd_exists() { command -v "$1" >/dev/null 2>&1 ; }

IS() { [ -d "$ROOTFS/$1" ] && { echo "+ [Installed]" ; } || echo "- [Not Installed]" ; }
pdsh() { x="$1" ; pd sh "$OS" --shared-tmp --no-sysvipc -- env DISPLAY=:1 $x ; }
check() { [ -d "$PROOT" ] && return || pd i "$OS" && termux-reload-settings ; }
timezone() { [ -f "$PROOT/etc/timezone" ] && return || echo "$(getprop persist.sys.timezone)" > $PROOT/etc/timezone ; }
update_pkgs() { pdsh "apt update -y" && pdsh "apt upgrade -y" && pdsh "apt autoremove -y" ; }

list_partitions() { sudo find /dev/block/bootdevice/by-name -type l -printf "%p -> " -exec readlink -f {} \; | awk '{print $NF, $0}' | sort | cut -d' ' -f2- ; }

idc() { pdsh "id $user" >/dev/null 2>&1 ; }

ascii_box() {
  ti="$1" ; mw=$((COLUMNS - 8)) ; bw=$mw ; b=$(printf '%*s' "$((bw-2))" | tr ' ' '=') ; pb="x${b}x" ; cw=$((bw - 6))
  echo "\n$pb\n|$(printf '%*s' "$((bw-2))")|" ; l=""
  for w in $ti; do
    if [ $((${#l} + ${#w} + 1)) -le $cw ]; then
      [ -n "$l" ] && l+=" " ; l+="$w"
    else
      p=$(( (bw - ${#l} - 2) / 2 ))
      printf "|%*s%s%*s|\n" $p "" "$l" $((bw - p - ${#l} - 2)) ""
      l="$w"
    fi
  done
  [ -n "$l" ] && { p=$(( (bw - ${#l} - 2) / 2 )) ; printf "|%*s%s%*s|\n" $p "" "$l" $((bw - p - ${#l} - 2)) "" ; }
  echo "|$(printf '%*s' "$((bw-2))")|\n$pb\n"
}

detect_env() {
  detect_arch() {
    BIN_DIR=$(pwd)/bin ; i=$(uname -m)
    case $i in
        arm) export ARCH=arm ;; aarch64) export ARCH=arm64 ;;
        x86) export ARCH=x86 ;; x86_64) export ARCH=x86_64 ;;
    esac
  }
  load_binaries() {
    BIN_EXEC="${BIN_DIR}/${ARCH}" ; i=$(uname -o)
    case $i in Android) export OS=android ; BIN_EXEC="${BIN_DIR}/${ARCH}/${OS}" ;; esac
    for cmd in $(ls -1 "$BIN_EXEC"); do [ -x "$BIN_EXEC/$cmd" ] && { chmod +x $BIN_EXEC/* ; export $cmd=$BIN_EXEC/$cmd ; } done
  }
  set_global_vars() {
    MOUNTED_IMGS=$(sudo $busybox mount | grep /mounted/ | awk '{print $3}' | sed 's/.*\///')
    SCRIPT_NAME="$(basename "$0" | sed 's|.*/||')"
    LOG_FILE=".log" ; TMP_FILE1=".tmp.1" ; TMP_FILE2=".tmp.2"
    silence() { "$@" >/dev/null 2>&1; }
  }
  detect_arch ; load_binaries ; set_global_vars
}

bcalc() {
  i=$1 && s=$2
  2kb() { echo "scale=2; $1 / (1024)" | bc; }
  2mb() { echo "scale=2; $1 / (1024*1024)" | bc; }
  2gb() { echo "scale=2; $1 / (1024*1024*1024)" | bc; }
  case "$s" in *) r=$(2$s "$i"); echo "$r" ;; esac
}
b2kb() { bcalc "$1" kb; } && b2mb() { bcalc "$1" mb; } && b2gb() { bcalc "$1" gb; }

install_ohmyzsh() {
  user_root="/home/$(whoami)"
  ohmyzsh="$user_root/.oh-my-zsh"
  cmd_exists() { command -v "$1" >/dev/null 2>&1 ; }
  if cmd_exists zsh; then
    if [ -d "$ohmyzsh" ]; then
      if [ -d "$ohmyzsh/custom/themes/powerlevel10k" ]; then
        if [ -d "$ohmyzsh/custom/plugins/zsh-autosuggestions" ]; then
          if [ -d "/usr/share/fonts/0xProto" ]; then
            echo "\nOh-my-zsh & powerlevel10k has been successfully installed.\n"
          else
            rm -r /usr/share/fonts/0xProto >/dev/null 2>&1
            wget https://github.com/ryanoasis/nerd-fonts/releases/download/v3.2.1/0xProto.zip -P /usr/share/fonts
            unzip /usr/share/fonts/0xProto.zip -d /usr/share/fonts/0xProto/
            rm /usr/share/fonts/0xProto.zip
            install_ohmyzsh
          fi
        else
          git clone https://github.com/zsh-users/zsh-autosuggestions "$ohmyzsh/custom/plugins/zsh-autosuggestions"
          sed -i 's/plugins=(\(git\))/plugins=(\n    \1\n    zsh-autosuggestions\n)/' "$user_root/.zshrc"
          install_ohmyzsh
        fi
      else
        git clone --depth=1 https://github.com/romkatv/powerlevel10k.git "$ohmyzsh/custom/themes/powerlevel10k"
        sed -i 's/^ZSH_THEME=.*$/ZSH_THEME="powerlevel10k\/powerlevel10k"/' "$user_root/.zshrc"
        echo "alias ls='lsd'" >> "$user_root/.zshrc"
        install_ohmyzsh
      fi
    else
      sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
      install_ohmyzsh
    fi
  else
    sudo apt update
    sudo apt install zsh lsd
    zsh=$(which zsh) && chsh -s "$zsh"
    install_ohmyzsh
  fi
}

metadata() {
  refresh_sizes() { silence rm -f $TMP_FILE1 $LOG_FILE
    find ./extracted -maxdepth 1 -name "*.img" -printf "%f %s\n" | sort -u >> $TMP_FILE1
    supertotal=$(stat -c '%s' ./super.img)
    imgtotal=$(find ./extracted -maxdepth 1 -name "*.img" -exec stat -c '%s' {} + | awk '{sum += $1} END {print sum}')
    echo -e "\nTotal Image Size: $imgtotal\nOverall Super Size: $supertotal\n" >> $TMP_FILE1
    $lpdump >> $TMP_FILE1
  }
  refresh_sizes

  ## functions that parse $TMP_FILE1 at certain coordinance for variable values
  size() { x="$1" && stat -c '%s' "$x" ; }
  parse() { x="$1"; y="$2" && echo "$x" | awk -v z="$y" '{print $z}' ; }
  sanitize() { grep -v '^[-]*$' | sed 's/^  *//' | paste -sd ' ' - | sed -e 's/:$//' -e 's/^(/ /' ; }
  attributes() { x="$1" && grep -e "Name: $x" -A2 "$TMP_FILE1" | sed -e '1,2d' -e 's/^  //' | awk '{print $2}' ; }
  extents() { x="$1" && grep -e "Name: $x" -A4 "$TMP_FILE1" | sed -e '1,4d' -e 's/^    //' ; }
  image_group() { x="$1" && grep -E "Partition table:" -A16 "$TMP_FILE1" | grep -e "Name: $x" -A4 ; }
  group_info() { x="$1" && grep -E "Group table:" -A16 "$TMP_FILE1" | grep -e "Name: $x" -A2 | sanitize ; }

  ## Calculate total size of all partitions inside super.img including super
  [ -f "./super.img" ] && {
    SUPER_PARTITION_NAME=$(grep "Partition name:" $TMP_FILE1 | sed -e 's/^  //' | awk '{print $3}')
    SUPER_SIZE=$(grep -e "Overall Super Size: " $TMP_FILE1 | awk '{print $4}')
    SUPER_TOTAL_MB=$(b2mb "$SUPER_SIZE") ; SUPER_TOTAL_GB=$(b2gb "$SUPER_SIZE")
    SUPER_LAYOUT=$(x="$1" && grep -e "super:" $TMP_FILE1 | sed 's/^super: //' | grep -e "$x")
    IMAGE_SIZE_TOTAL=$(grep -e "Total Image Size: " $TMP_FILE1 | awk '{print $4}')
    IMAGE_SIZE_TOTAL_MB=$(b2mb "$IMAGE_SIZE_TOTAL") ; IMAGE_SIZE_TOTAL_GB=$(b2gb "$IMAGE_SIZE_TOTAL")
    METADATA_VERSION=$(grep -e "Metadata version: " $TMP_FILE1 | awk '{print $3}')
    METADATA_SIZE=$(grep -e "Metadata size: " $TMP_FILE1 | awk '{print $3}')
    METADATA_MAX_SIZE=$(grep -e "Metadata max size: " $TMP_FILE1 | awk '{print $4}')
    METADATA_SLOT_COUNT=$(grep -e "Metadata slot count: " $TMP_FILE1 | awk '{print $4}')
    HEADER_FLAGS=$(grep -e "Header flags: " $TMP_FILE1 | awk '{print $3}')
    BLOCK_DEVICE_TABLE=$(grep -e "Block device table:" -A5 $TMP_FILE1 | sed '1,2d')
  }

  [ -f "./extracted/product_a.img" ] && {
    PRODUCT_A_NAME="product_a"
    PRODUCT_A_SIZE=$(size "./extracted/product_a.img" || echo "0")
    PRODUCT_A_SIZE_MB=$(b2mb "$PRODUCT_A_SIZE") ; PRODUCT_A_SIZE_GB=$(b2gb "$PRODUCT_A_SIZE")
    PRODUCT_A_ATTRIBUTES=$(a() { [ -z "$(attributes product_a)" ] && {echo "none"} ; } && a || echo "none") ; PRODUCT_A_EXTENTS=$(extents "product_a")
    PRODUCT_A_LAYOUT=$(echo "$SUPER_LAYOUT" | grep "product_a" || echo "0")
    PRODUCT_A_SECTOR_BEGIN=$(parse "$PRODUCT_A_LAYOUT" 1)
    PRODUCT_A_SECTOR_FINISH=$(parse "$PRODUCT_A_LAYOUT" 3 | sanitize)
    PRODUCT_A_SECTOR_SIZE=$(parse "$PRODUCT_A_LAYOUT" 5 | sanitize)
    PRODUCT_A_GROUP_NAME=$(a() { [ -z "$(image_group product_a | sed '1d;3,5d' | awk '{print $2}')" ] && {echo "main_a"} ; } && a || echo "main_a")

    PRODUCT_B_NAME="product_b"
    PRODUCT_B_SIZE=$(size "./extracted/product_b.img" || echo "0")
    PRODUCT_B_SIZE_MB=$(b2mb "$PRODUCT_B_SIZE") ; PRODUCT_B_SIZE_GB=$(b2gb "$PRODUCT_B_SIZE")
    PRODUCT_B_ATTRIBUTES=$(a() { [ -z "$(attributes product_b)" ] && {echo "none"} ; } && a || echo "none") ; PRODUCT_B_EXTENTS=$(extents "product_b")
    PRODUCT_B_LAYOUT=$(echo "$SUPER_LAYOUT" | grep "product_b" || echo "0")
    PRODUCT_B_SECTOR_BEGIN=$(parse "$PRODUCT_B_LAYOUT" 1)
    PRODUCT_B_SECTOR_FINISH=$(parse "$PRODUCT_B_LAYOUT" 3 | sanitize)
    PRODUCT_B_SECTOR_SIZE=$(parse "$PRODUCT_B_LAYOUT" 5 | sanitize)
    PRODUCT_B_GROUP_NAME=$(a() { [ -z "$(image_group product_b | sed '1d;3,5d' | awk '{print $2}')" ] && {echo "main_b"} ; } && a || echo "main_b")
    PRODUCT_TOTAL_SIZE=$(echo "$PRODUCT_A_SIZE + $PRODUCT_B_SIZE" | bc)
    PRODUCT_TOTAL_MB=$(b2mb "$PRODUCT_TOTAL_SIZE") ; PRODUCT_TOTAL_GB=$(b2gb "$PRODUCT_TOTAL_SIZE")
  }

  [ -f "./extracted/system_a.img" ] && {
    SYSTEM_A_NAME="system_a"
    SYSTEM_A_SIZE=$(size "./extracted/system_a.img" || echo "0")
    SYSTEM_A_SIZE_MB=$(b2mb "$SYSTEM_A_SIZE") ; SYSTEM_A_SIZE_GB=$(b2gb "$SYSTEM_A_SIZE")
    SYSTEM_A_ATTRIBUTES=$(a() { [ -z "$(attributes system_a)" ] && {echo "none"} ; } && a || echo "none") ; SYSTEM_A_EXTENTS=$(extents "system_a" || echo "0")
    SYSTEM_A_LAYOUT=$(echo "$SUPER_LAYOUT" | grep "system_a" || echo "0")
    SYSTEM_A_SECTOR_BEGIN=$(parse "$SYSTEM_A_LAYOUT" 1)
    SYSTEM_A_SECTOR_FINISH=$(parse "$SYSTEM_A_LAYOUT" 3 | sanitize)
    SYSTEM_A_SECTOR_SIZE=$(parse "$SYSTEM_A_LAYOUT" 5 | sanitize)
    SYSTEM_A_GROUP_NAME=$(a() { [ -z "$(image_group system_a | sed '1d;3,5d' | awk '{print $2}')" ] && {echo "main_a"} ; } && a || echo "main_a")

    SYSTEM_B_NAME="system_b"
    SYSTEM_B_SIZE=$(size "./extracted/system_b.img" || echo "0")
    SYSTEM_B_SIZE_MB=$(b2mb "$SYSTEM_B_SIZE") ; SYSTEM_B_SIZE_GB=$(b2gb "$SYSTEM_B_SIZE")
    SYSTEM_B_ATTRIBUTES=$(a() { [ -z "$(attributes system_b)" ] && {echo "none"} ; } && a || echo "none") ; SYSTEM_B_EXTENTS=$(extents "system_b" || echo "0")
    SYSTEM_B_LAYOUT=$(echo "$SUPER_LAYOUT" | grep "system_b" || echo "0")
    SYSTEM_B_SECTOR_BEGIN=$(parse "$SYSTEM_B_LAYOUT" 1 )
    SYSTEM_B_SECTOR_FINISH=$(parse "$SYSTEM_B_LAYOUT" 3 | sanitize)
    SYSTEM_B_SECTOR_SIZE=$(parse "$SYSTEM_B_LAYOUT" 5 | sanitize)
    SYSTEM_B_GROUP_NAME=$(a() { [ -z "$(image_group system_b | sed '1d;3,5d' | awk '{print $2}')" ] && {echo "main_b"} ; } && a || echo "main_b")
    SYSTEM_TOTAL_SIZE=$(echo "$SYSTEM_A_SIZE + $SYSTEM_B_SIZE" | bc)
    SYSTEM_TOTAL_MB=$(b2mb "$SYSTEM_TOTAL_SIZE") ; SYSTEM_TOTAL_GB=$(b2gb "$SYSTEM_TOTAL_SIZE")
  }

  [ -f "./extracted/vendor_a.img" ] && {
    VENDOR_A_NAME="vendor_a"
    VENDOR_A_SIZE=$(size "./extracted/vendor_a.img" || echo "0")
    VENDOR_A_SIZE_MB=$(b2mb "$VENDOR_A_SIZE") ; VENDOR_A_SIZE_GB=$(b2gb "$VENDOR_A_SIZE")
    VENDOR_A_ATTRIBUTES=$(a() { [ -z "$(attributes vendor_a)" ] && {echo "none"} ; } && a || echo "none") ; VENDOR_A_EXTENTS=$(extents "vendor_a" || echo "0")
    VENDOR_A_LAYOUT=$(echo "$SUPER_LAYOUT" | grep "vendor_a" || echo "0")
    VENDOR_A_SECTOR_BEGIN=$(parse "$VENDOR_A_LAYOUT" 1 )
    VENDOR_A_SECTOR_FINISH=$(parse "$VENDOR_A_LAYOUT" 3 | sanitize)
    VENDOR_A_SECTOR_SIZE=$(parse "$VENDOR_A_LAYOUT" 5 | sanitize)
    VENDOR_A_GROUP_NAME=$(a() { [ -z "$(image_group vendor_a | sed '1d;3,5d' | awk '{print $2}')" ] && {echo "main_a"} ; } && a || echo "main_a")

    VENDOR_B_NAME="vendor_b"
    VENDOR_B_SIZE=$(size "./extracted/vendor_b.img" || echo "0")
    VENDOR_B_SIZE_MB=$(b2mb "$VENDOR_B_SIZE") ; VENDOR_B_SIZE_GB=$(b2gb "$VENDOR_B_SIZE")
    VENDOR_B_ATTRIBUTES=$(a() { [ -z "$(attributes vendor_b)" ] && {echo "none"} ; } && a || echo "none") ; VENDOR_B_EXTENTS=$(extents "vendor_b" || echo "0")
    VENDOR_B_LAYOUT=$(echo "$SUPER_LAYOUT" | grep "vendor_b" || echo "0")
    VENDOR_B_SECTOR_BEGIN=$(parse "$VENDOR_B_LAYOUT" 1)
    VENDOR_B_SECTOR_FINISH=$(parse "$VENDOR_B_LAYOUT" 3 | sanitize)
    VENDOR_B_SECTOR_SIZE=$(parse "$VENDOR_B_LAYOUT" 5 | sanitize)
    VENDOR_B_GROUP_NAME=$(a() { [ -z "$(image_group vendor_b | sed '1d;3,5d' | awk '{print $2}')" ] && {echo "main_b"} ; } && a || echo "main_b")
    VENDOR_TOTAL_SIZE=$(echo "$VENDOR_A_SIZE + $VENDOR_B_SIZE" | bc)
    VENDOR_TOTAL_MB=$(b2mb "$VENDOR_TOTAL_SIZE") ; VENDOR_TOTAL_GB=$(b2gb "$VENDOR_TOTAL_SIZE")
  }

  [ -f "./extracted/product_a.img" ] && [ -f "./extracted/system_a.img" ] && [ -f "./extracted/vendor_a.img" ] && {
    MAIN_A_TOTAL_SIZE=$(echo "$PRODUCT_A_SIZE + $SYSTEM_A_SIZE + $VENDOR_A_SIZE" | bc || echo "0")
    MAIN_A_TOTAL_MB=$(b2mb "$MAIN_A_TOTAL_SIZE") ; MAIN_A_TOTAL_GB=$(b2gb "$MAIN_A_TOTAL_SIZE")
    MAIN_A_MAX_SIZE=$(group_info "main_a" | awk '{print $5}') ; MAIN_A_MAX_MB=$(b2mb "$MAIN_A_MAX_SIZE")
    MAIN_A_MAX_GB=$(b2gb "$MAIN_A_MAX_SIZE") ; MAIN_A_FLAGS=$(group_info "main_a" | awk '{print $8}')

    MAIN_B_TOTAL_SIZE=$(echo "$PRODUCT_B_SIZE + $SYSTEM_B_SIZE + $VENDOR_B_SIZE" | bc || echo "0")
    MAIN_B_TOTAL_MB=$(b2mb "$MAIN_B_TOTAL_SIZE") ; MAIN_B_TOTAL_GB=$(b2gb "$MAIN_B_TOTAL_SIZE")
    MAIN_B_MAX_SIZE=$(group_info "main_b" | awk '{print $5}') ; MAIN_B_MAX_MB=$(b2mb "$MAIN_B_MAX_SIZE")
    MAIN_B_MAX_GB=$(b2gb "$MAIN_B_MAX_SIZE") MAIN_B_FLAGS=$(group_info "main_b" | awk '{print $8}')
  }
}

dump_log() {

  silence metadata
  silence rm -f $LOG_FILE

{
cat << EOF
$(ascii_box "Super Partition Table:")

* Name: $PRODUCT_A_NAME
   Group: $PRODUCT_A_GROUP_NAME
     Attributes: $PRODUCT_A_ATTRIBUTES
      Size: $PRODUCT_A_SIZE B
            $PRODUCT_A_SIZE_MB MB
            $PRODUCT_A_SIZE_GB GB

      Extents:
  $PRODUCT_A_EXTENTS

* Name: $PRODUCT_B_NAME
   Group: $PRODUCT_B_GROUP_NAME
     Attributes: $PRODUCT_B_ATTRIBUTES
      Size: $PRODUCT_B_SIZE B
            $PRODUCT_B_SIZE_MB MB
            $PRODUCT_B_SIZE_GB GB

      Extents:
  $PRODUCT_B_EXTENTS

* Product Total: $PRODUCT_TOTAL_SIZE B
                 $PRODUCT_TOTAL_MB MB
                 $PRODUCT_TOTAL_GB GB

* Name: $SYSTEM_A_NAME
   Group: $SYSTEM_A_GROUP_NAME
     Attributes: $SYSTEM_A_ATTRIBUTES
      Size: $SYSTEM_A_SIZE B
            $SYSTEM_A_SIZE_MB MB
            $SYSTEM_A_SIZE_GB GB

      Extents:
  $SYSTEM_A_EXTENTS

* Name: $SYSTEM_B_NAME
   Group: $SYSTEM_B_GROUP_NAME
     Attributes: $SYSTEM_B_ATTRIBUTES
      Size: $SYSTEM_B_SIZE B
            $SYSTEM_B_SIZE_MB MB
            $SYSTEM_B_SIZE_GB GB

      Extents:
  $SYSTEM_B_EXTENTS

* System Total: $SYSTEM_TOTAL_SIZE B
                $SYSTEM_TOTAL_MB MB
                $SYSTEM_TOTAL_GB GB

* Name: $VENDOR_A_NAME
   Group: $VENDOR_A_GROUP_NAME
     Attributes: $VENDOR_A_ATTRIBUTES
      Size: $VENDOR_A_SIZE B
            $VENDOR_A_SIZE_MB MB
            $VENDOR_A_SIZE_GB GB

      Extents:
  $VENDOR_A_EXTENTS

* Name: $VENDOR_B_NAME
   Group: $VENDOR_B_GROUP_NAME
     Attributes: $VENDOR_B_ATTRIBUTES
      Size: $VENDOR_B_SIZE B
            $VENDOR_B_SIZE_MB MB
            $VENDOR_B_SIZE_GB GB

      Extents:
  $VENDOR_B_EXTENTS

* Vendor Total: $VENDOR_TOTAL_SIZE B
                $VENDOR_TOTAL_MB MB
                $VENDOR_TOTAL_GB GB

$(ascii_box "Group Table Information:")

*  Name: $GROUP_DEFAULT_NAME
     Maximum size: $GROUP_DEFAULT_MAX_SIZE B
     Flags: $GROUP_DEFAULT_FLAGS

*  Name: main_a
     Current size: $MAIN_A_TOTAL_SIZE B
     Maximum size: $MAIN_A_MAX_SIZE B
     Flags: $MAIN_A_FLAGS

*  Name: main_b
     Current size: $MAIN_B_TOTAL_SIZE B
     Maximum size: $MAIN_B_MAX_SIZE B
     Flags: $MAIN_B_FLAGS

$(ascii_box "Block device table:")

$BLOCK_DEVICE_TABLE

$(ascii_box "Super Layout:")

$SUPER_LAYOUT

$(ascii_box "Super Overview:")

$SUPER_PARTITION_NAME max size: $SUPER_SIZE B $SUPER_TOTAL_MB MB $SUPER_TOTAL_GB GB

Image sizes:    $IMAGE_SIZE_TOTAL B $IMAGE_SIZE_TOTAL_MB MB $IMAGE_SIZE_TOTAL_GB GB

main_a:         $MAIN_A_TOTAL_SIZE B $MAIN_A_TOTAL_MB MB $MAIN_A_TOTAL_GB GB
|
|_$PRODUCT_A_NAME:    $PRODUCT_A_SIZE B $PRODUCT_A_SIZE_MB MB $PRODUCT_A_SIZE_GB GB
|_$SYSTEM_A_NAME:     $SYSTEM_A_SIZE B $SYSTEM_A_SIZE_MB MB $SYSTEM_A_SIZE_GB GB
|_$VENDOR_A_NAME:     $VENDOR_A_SIZE B $VENDOR_A_SIZE_MB MB $VENDOR_A_SIZE_GB GB

main_b:                  $MAIN_B_TOTAL_SIZE B       $MAIN_B_TOTAL_MB MB    $MAIN_B_TOTAL_GB GB
|
|_$PRODUCT_B_NAME:             $PRODUCT_B_SIZE B       $PRODUCT_B_SIZE_MB MB    $PRODUCT_B_SIZE_GB GB
|_$SYSTEM_B_NAME:              $SYSTEM_B_SIZE B       $SYSTEM_B_SIZE_MB MB    $SYSTEM_B_SIZE_GB GB
|_$VENDOR_B_NAME:              $VENDOR_B_SIZE B       $VENDOR_B_SIZE_MB MB    $VENDOR_B_SIZE_GB GB

$(ascii_box "lpmake command")

lpmake \
--metadata-size $METADATA_MAX_SIZE \
--super-name=$SUPER_PARTITION_NAME \
--device-size=$SUPER_SIZE \
--metadata-slots=$METADATA_SLOT_COUNT \
--group=main_a:$MAIN_A_TOTAL_SIZE \
--group=main_b:$MAIN_B_TOTAL_SIZE \
--image=$PRODUCT_A_NAME=./extracted/$PRODUCT_A_NAME.img \
--partition=$PRODUCT_A_NAME:$PRODUCT_A_ATTRIBUTES:$PRODUCT_A_SIZE:$PRODUCT_A_GROUP_NAME \
--image=$PRODUCT_B_NAME=./extracted/$PRODUCT_B_NAME.img \
--partition=$PRODUCT_B_NAME:$PRODUCT_B_ATTRIBUTES:$PRODUCT_B_SIZE:$PRODUCT_B_GROUP_NAME \
--image=$SYSTEM_A_NAME=./extracted/$SYSTEM_A_NAME.img \
--partition=$SYSTEM_A_NAME:$SYSTEM_A_ATTRIBUTES:$SYSTEM_A_SIZE:$SYSTEM_A_GROUP_NAME \
--image=$SYSTEM_B_NAME=./extracted/$SYSTEM_B_NAME.img \
--partition=$SYSTEM_B_NAME:$SYSTEM_B_ATTRIBUTES:$SYSTEM_B_SIZE:$SYSTEM_B_GROUP_NAME \
--image=$VENDOR_A_NAME=./extracted/$VENDOR_A_NAME.img \
--partition=$VENDOR_A_NAME:$VENDOR_A_ATTRIBUTES:$VENDOR_A_SIZE:$VENDOR_A_GROUP_NAME \
--image=$VENDOR_B_NAME=./extracted/$VENDOR_B_NAME.img \
--partition=$VENDOR_B_NAME:$VENDOR_B_ATTRIBUTES:$VENDOR_B_SIZE:$VENDOR_B_GROUP_NAME \
--virtual-ab \
--sparse \
--output ./out/new_super$HASHSTAMP.img

EOF
} >> $LOG_FILE
  return 0
}

dump_variables() {
  dump_log && echo "$(ascii_box "Useful Variables")\n" >> $LOG_FILE
  sed -n 's/[^ ]*=[^ ]*/\n&\n/gp' $SCRIPT_NAME | grep '=' | \
  awk -F'=' '{gsub(/[^A-Z_]/, "", $1); if ($1 != "") print $1}' | \
  sed 's/\($F\|NR\)//g' | sort -u | head -n -1 | \
  sed -e '3d' -e '/^F$/d' -e '/^IFS/d' -e '/^LP/d' -e '/^L/d' >> $TMP_FILE2
  while IFS= read -r var_name; do
    [ -n "$var_name" ] && [ "${var_name#\#}" = "$var_name" ] && { var_value=$(eval echo "\$$var_name") ; output+="$var_name=$var_value\n" ; }
  done < $TMP_FILE2
  [ -n "$output" ] && { echo -e "$output" | grep -v "^_=" >> $LOG_FILE ; }
  rm -f $TMP_FILE2 && cat $LOG_FILE && return 0
}

calculate_hash() {
  compare_hashes() {
    find_hash_file() { HASH_FILE=".previous_hash" ; [ -f "$HASH_FILE" ] && { previous_log=$(cat "$HASH_FILE") ; return 0 ; } || echo "\nNo previous hash found. This might be the first run." ; }
    find_log_file() { [ ! -f "$LOG_FILE" ] && { echo "Generating hashes...\n" && touch "$LOG_FILE" ; return 0 ; } ; }
    hash_changed() { DISPLAY_HASH=$(echo "Current hash: $current_hash | Previous hash: $previous_log") ; }
    calculate_hash() { current_hash=$(sha256sum "$LOG_FILE" | awk '{print substr($1, 1, 7)}') ; [ "$current_hash" != "$previous_log" ] && { hash_changed ; return 0 ; } || DISPLAY_HASH=$(echo "Current hash: $current_hash | Previous hash: $previous_log") ; }
    find_hash_file ; find_log_file ; calculate_hash
  }
  compare_hashes && echo "$current_hash" > "$HASH_FILE" && HASHSTAMP=$(echo _$current_hash)
}


